# k8s/base/postgres.yaml
# ============================================================================
# PostgreSQL for MLflow Backend Store
# ============================================================================
# WHY: MLflow needs a database to store:
#   - Experiment metadata (names, IDs, lifecycle stage)
#   - Run information (start time, end time, status)
#   - Parameters logged during training (n_estimators, learning_rate, etc.)
#   - Metrics logged during training (accuracy, f1_score, loss, etc.)
#   - Model Registry data (model names, versions, stage transitions)
#
# WHY POSTGRESQL (not SQLite)?
#   - Concurrent access: Multiple Prefect workers can log simultaneously
#   - ACID transactions: No data corruption during failures
#   - Scalability: Handles thousands of runs without performance issues
#   - Production-grade: Battle-tested in enterprise environments
# ============================================================================

---
# ============================================================================
# SECRET: Database Credentials
# ============================================================================
# WHY A SECRET (not ConfigMap)?
#   - Passwords should never be in plain-text ConfigMaps
#   - Secrets are base64 encoded (not encrypted, but a first step)
#   - In production: Use External Secrets Operator or Vault
#
# HOW TO GENERATE BASE64:
#   echo -n 'your_password' | base64
#   Example: echo -n 'mlflow_password' | base64  â†’  bWxmbG93X3Bhc3N3b3Jk
# ============================================================================
apiVersion: v1
kind: Secret
metadata:
  name: postgres-secret
  namespace: fraud-detection
  labels:
    app: postgres
    component: mlflow-backend
type: Opaque
data:
  # Base64 encoded values (decode: echo 'bWxmbG93' | base64 -d)
  # Plain text: mlflow
  POSTGRES_USER: bWxmbG93
  # Plain text: mlflow_password (CHANGE IN PRODUCTION!)
  POSTGRES_PASSWORD: bWxmbG93X3Bhc3N3b3Jk
  # Plain text: mlflow_db
  POSTGRES_DB: bWxmbG93X2Ri

---
# ============================================================================
# PERSISTENT VOLUME CLAIM: Data Storage
# ============================================================================
# WHY PERSISTENT STORAGE?
#   - Pod restarts shouldn't lose all experiment history
#   - Database files need to survive container lifecycle
#   - PVC is backed by Minikube's hostPath (local disk)
#
# SIZE CONSIDERATION:
#   - 1Gi is enough for development (thousands of runs)
#   - Production: 10Gi+ depending on experiment volume
#   - Only stores metadata (not artifacts - those go to MinIO)
# ============================================================================
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
  namespace: fraud-detection
  labels:
    app: postgres
    component: mlflow-backend
spec:
  accessModes:
    - ReadWriteOnce  # Only one pod can write (PostgreSQL is single-master)
  resources:
    requests:
      storage: 1Gi
  # Uses Minikube's default StorageClass (standard)

---
# ============================================================================
# DEPLOYMENT: PostgreSQL Server
# ============================================================================
# WHY DEPLOYMENT (not StatefulSet)?
#   - Single replica is fine for development/learning
#   - StatefulSet is for: stable network IDs, ordered scaling, complex DBs
#   - For production HA: Consider CloudNativePG operator or managed DB
#
# IMAGE: postgres:15-alpine
#   - Alpine = smaller image (~80MB vs ~150MB)
#   - PostgreSQL 15 = Latest stable with good performance
# ============================================================================
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres
  namespace: fraud-detection
  labels:
    app: postgres
    component: mlflow-backend
spec:
  replicas: 1  # Single instance (not HA - acceptable for learning)
  selector:
    matchLabels:
      app: postgres
  # Recreate strategy: Stop old pod before starting new one
  # WHY? PostgreSQL can't have two instances writing to same volume
  strategy:
    type: Recreate
  template:
    metadata:
      labels:
        app: postgres
        component: mlflow-backend
    spec:
      containers:
        - name: postgres
          image: postgres:15-alpine
          
          # ----------------------------------------------------------------
          # PORT: Standard PostgreSQL port
          # ----------------------------------------------------------------
          ports:
            - containerPort: 5432
              name: postgres
          
          # ----------------------------------------------------------------
          # ENVIRONMENT: Database initialization
          # ----------------------------------------------------------------
          # On first start, PostgreSQL creates:
          #   - User from POSTGRES_USER
          #   - Password from POSTGRES_PASSWORD
          #   - Database from POSTGRES_DB
          # ----------------------------------------------------------------
          env:
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: postgres-secret
                  key: POSTGRES_USER
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: postgres-secret
                  key: POSTGRES_PASSWORD
            - name: POSTGRES_DB
              valueFrom:
                secretKeyRef:
                  name: postgres-secret
                  key: POSTGRES_DB
            # Performance: Disable fsync for faster dev performance
            # WARNING: Remove this in production (data loss risk on crash)
            - name: POSTGRES_INITDB_ARGS
              value: "--data-checksums"
          
          # ----------------------------------------------------------------
          # VOLUME MOUNT: Where PostgreSQL stores data
          # ----------------------------------------------------------------
          volumeMounts:
            - name: postgres-storage
              mountPath: /var/lib/postgresql/data
              # subPath prevents permission issues with PVC root
              subPath: pgdata
          
          # ----------------------------------------------------------------
          # HEALTH CHECKS: Kubernetes needs to know if PostgreSQL is ready
          # ----------------------------------------------------------------
          # Liveness: Is the process alive? (Restart if not)
          livenessProbe:
            exec:
              command:
                - pg_isready
                - -U
                - mlflow  # Must match POSTGRES_USER
                - -d
                - mlflow_db  # Must match POSTGRES_DB
            initialDelaySeconds: 30  # Give PostgreSQL time to start
            periodSeconds: 10
            timeoutSeconds: 5
            failureThreshold: 3
          
          # Readiness: Can it accept connections? (Don't route traffic if not)
          readinessProbe:
            exec:
              command:
                - pg_isready
                - -U
                - mlflow
                - -d
                - mlflow_db
            initialDelaySeconds: 5
            periodSeconds: 5
            timeoutSeconds: 3
            failureThreshold: 3
          
          # ----------------------------------------------------------------
          # RESOURCES: Memory/CPU limits
          # ----------------------------------------------------------------
          # PostgreSQL is memory-hungry for caching
          # These are conservative for Minikube
          resources:
            requests:
              memory: "128Mi"
              cpu: "100m"
            limits:
              memory: "512Mi"
              cpu: "500m"
      
      # --------------------------------------------------------------------
      # VOLUMES: Connect PVC to pod
      # --------------------------------------------------------------------
      volumes:
        - name: postgres-storage
          persistentVolumeClaim:
            claimName: postgres-pvc

---
# ============================================================================
# SERVICE: Internal DNS for PostgreSQL
# ============================================================================
# WHY A SERVICE?
#   - Pods get random IPs that change on restart
#   - Service provides stable DNS: postgres-service.fraud-detection.svc.cluster.local
#   - Or simply: postgres-service (within same namespace)
#
# CONNECTION STRING FOR MLFLOW:
#   postgresql://mlflow:mlflow_password@postgres-service:5432/mlflow_db
# ============================================================================
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
  namespace: fraud-detection
  labels:
    app: postgres
    component: mlflow-backend
spec:
  type: ClusterIP  # Internal only (no external access needed)
  selector:
    app: postgres  # Routes to pods with this label
  ports:
    - port: 5432        # Service port
      targetPort: 5432  # Container port
      protocol: TCP
      name: postgres